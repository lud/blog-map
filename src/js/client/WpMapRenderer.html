<div ref:leaflet id="wpmap-map-{mapID}" class="wpmap-map">
  <slot>Hello !</slot>
</div>

<style>
  .wpmap-map {
    height: 300px;
  }
</style>

<script>
  import 'leaflet/dist/leaflet.css'
  import 'leaflet-vector-icon/dist/leaflet-vector-icon.css'
  import L from 'leaflet'
  import VectorIcon from 'leaflet-vector-icon'
  import 'leaflet-providers'
  import 'leaflet-active-area'
  import FeatureStyle from './feature-style'
  import {
    buildBackgroundLayer,
  } from './leaflet-helpers'

  const META_HIGHL = 'layer:highlighted'
  const META_HOVER = 'layer:hovered'

  function mountMap(el) {
    const map = L.map(el).setView([0, 0], 10)
    return { map }
  }

  function setMapBackground(map, backgroundKey) {
    console.log('set background %s', backgroundKey)
    // remove the current background
    const currentBackGround = map.meta('background')
    if (currentBackGround) {
      map.removeLayer(currentBackGround)
    }
    const newBackground = buildBackgroundLayer(backgroundKey)
    if (!newBackground) {
      console.error("Could not build background for key : %s", backgroundKey)
      return
    }
    map.meta('background', newBackground)
    map.addLayer(newBackground)
    newBackground.bringToBack()
  }

  function getStyleName(layer, currentHoveredLayer, currentHighlightedLayer) {
    const baseStyle = layer === currentHoveredLayer
      ? 'hover'
      : 'default'
    const prefix = layer === currentHighlightedLayer
      ? 'highlight-'
      : ''
    return prefix + baseStyle
  }

  // Generate map pins :
// medium.com/welldone-software/map-pins-using-svg-path-9fdfebb74501
// The pin is defined by 4 points :
//  - A is the tip of the pin
//  - C is the center of the circle (top part of the pin)
//  - B (left) and D (right) are the two points where the circle
//    connects with the straight lines going to A
// The shape is A --> B ~~> D --> A
//   where --> is a straight line
//     and ~~> a circle arc revolving around C
// dX is the horizontal delta between A and D (and negative for B)
// dY is the vertical delta between A and B && A and D (negative for
//   both as SVG Y is growing downwards)
function pinPath(radius, height) {
    if (height <= radius * 2) {
      height = radius * 2 + 1
    }
    const alpha = Math.acos(radius / (height - radius))
    const deltaX = radius * Math.sin(alpha)
    const deltaY = height * (height - radius * 2) / (height - radius)
    const Ax = 0, Ay = 0, Bx = -deltaX, By = -deltaY, Dx = deltaX, Dy = -deltaY
    console.log('radius: %s, height: %s, alpha: %s, deltaX: %s, deltaY: %s', radius, height, alpha, deltaX, deltaY)
    return `M ${Ax},${Ay}
            L ${Bx},${By}
            A ${radius} ${radius} 1 1 1 ${Dx},${Dy}
            L ${Ax},${Ay} z`
}

  // -------------------------------------------------------------------------
  // Component start
  // -------------------------------------------------------------------------

  export default {
    data() {
      return {
        background: null,
        collection: null,
        featureStyle: new FeatureStyle(),
        selection: {},
      }
    },
    oncreate() {
      const { map } = mountMap(this.refs.leaflet)
      const { background, collection, featureStyle, activeArea } = this.get()
      console.log('oncreate background', background)
      console.log('oncreate collection', collection)
      this.set({ map })
      this.applyActiveArea(activeArea)
    },
    onupdate({ changed, current, previous }) {
      // most code here must act on the map, but onstate() is fired once before
      // oncreate(), and the map is created on oncreate(). So we test for the
      // presence of the map in the state before acting on it
      if (current.map && changed.background && current.background) {
        setMapBackground(current.map, current.background)
      }
      if (current.map && changed.collection && current.collection) {
        console.log('current.collection is cool : ', current.collection)
        console.log('so we call setupFeaturesLayer()')
        this.setupFeaturesLayer()
      }
      if (current.map && changed.activeArea) {
        this.applyActiveArea(current.activeArea)
      }
    },
    methods: {
      setupFeaturesLayer() {
        const CONF_PIN_RADIUS = 22
        const CONF_PIN_HEIGHT = 50
        const iconSize = [CONF_PIN_RADIUS * 2, CONF_PIN_HEIGHT]
        const iconAnchor = [CONF_PIN_RADIUS, CONF_PIN_HEIGHT]
        const mapPin = pinPath(CONF_PIN_RADIUS, CONF_PIN_HEIGHT)
        // viewbox is x y w h, not x1 y1 x2 y2
        const viewBox = `${-CONF_PIN_RADIUS} ${-CONF_PIN_HEIGHT} ${CONF_PIN_RADIUS * 2} ${CONF_PIN_HEIGHT}`
        let DEBUG_FAKE_CLICK_LAYER
        const self = this
        const { map, collection, featureStyle } = self.get()
        console.log('setupFeaturesLayer collection', collection)
        const groupLayer = L.geoJson(collection, {
            pointToLayer: function(feat, latlng) {
              console.log('mapPin', mapPin)
              const icon = new VectorIcon({
                icon: 'circle',
                iconSize,
                iconAnchor,
                mapPin,
                viewBox,
                markerColor: 'rgba(100, 100, 200, 0.5)',
              })
              console.log('icon', icon)
              const layer = L.marker(latlng, { icon })
              featureStyle.setLayerStyle(layer, 'default')
              DEBUG_FAKE_CLICK_LAYER = layer // we will get the last one
              return layer
            }
          })
          .on('click', function(group) {
            self.fire('click_feature', {
              feature: group.layer.feature,
              layer: group.layer,
              group
            })
          })
          .on('mouseover', function({ layer }) {
            map.meta(META_HOVER, layer)
            const styleName = getStyleName(layer, layer, map.meta(META_HIGHL))
            featureStyle.setLayerStyle(layer, styleName)
          })
          .on('mouseout', function({ layer }) {
            map.meta(META_HOVER, null)
            const styleName = getStyleName(layer, null, map.meta(META_HIGHL))
            featureStyle.setLayerStyle(layer, styleName)
          })

          // setTimeout(function(){
          //   self.fire('click_feature', {
          //     feature: DEBUG_FAKE_CLICK_LAYER.feature,
          //     layer: DEBUG_FAKE_CLICK_LAYER,
          //     group: 'debug undef'
          //   })
          // }, 1)
        if (collection.features.length > 1) {
          map.fitBounds(groupLayer.getBounds(), {
            padding: [50, 50],
            animate: false
          })
        } else {
          // geojson is lonlat, but leaflet is latlng
          const [lng, lat] = collection.features[0].geometry.coordinates
          map.setView([lat, lng], 10)
        }
        map.addLayer(groupLayer)
        groupLayer.bringToFront()
      },
      setHighlightedLayer(layer, changeViewMethod, ...zoomArgs) {
        const { map, featureStyle } = this.get()
        let previous = map.meta(META_HIGHL)
        if (previous) {
          const styleName = getStyleName(previous, map.meta(META_HOVER), layer)
          featureStyle.setLayerStyle(previous, styleName)
        }
        map.meta(META_HIGHL, layer)
        if (layer) {
          const styleName = getStyleName(layer, map.meta(META_HOVER), layer)
          featureStyle.setLayerStyle(layer, styleName)
          if (changeViewMethod && changeViewMethod in map) {
            console.log(changeViewMethod, layer.getLatLng())
            map[changeViewMethod](layer.getLatLng(), ...zoomArgs)
          } else if (changeViewMethod) {
            throw new Error("No map method " + changeViewMethod)
          }
        }
      },
      panToLayerLng(layer) {
        const { map } = this.get()
        // latitude of the map, but longitude of the layer, so this pans only
        // horizontally (so its called "center vertically")
        this.panToTwoObjects(map.getCenter(), layer.getLatLng())
      },
      panToLayerLat(layer) {
        const { map } = this.get()
        // cf. panToLayerLng
        this.panToTwoObjects(layer.getLatLng(), map.getCenter())
      },
      panToLayer(layer) {
        console.warn('@todo pan only if the map does not already contain the layer')
        const { map } = this.get()
        map.panTo(layer.getLatLng(), {
          duration: 0.6
        })
      },
      panToTwoObjects({ lat }, { lng }) {
        const { map } = this.get()
        map.panTo(L.latLng(lat, lng), {
          duration: 0.3
        })
      },
      applyActiveArea(params) {
        const { map } = this.get()
        const css = Object.assign({position:'absolute'}, params)
        console.log('apply active area', JSON.stringify(css))
        map.setActiveArea(css)
      }
    }
  }
</script>
